# MemoryLinkCMS 認証アーキテクチャ (最終決定版)

## 概要

このドキュメントは、MemoryLinkCMSにおける、現在稼働している**唯一の正しい認証フロー**を定義するものである。
過去に発生したログインループや状態の不整合といった問題をすべて解決した、このクライアントサイド主導のアーキテクチャは、今後の開発における認証の「正解」とする。いかなる変更も、ここに記載された原則を逸脱してはならない。

---

## 設計思想：クライアントサイドの`onAuthStateChanged`を絶対的な正義とする

このアーキテクチャの核心は、**「認証状態の判断を、Firebase Client SDKが提供する`onAuthStateChanged`に完全に一任する」**という一点にある。

Next.jsのサーバーサイド（`middleware`やAPIルート）でセッションCookieを検証してリダイレクトを行う方法は、クライアントの認証状態とサーバーのセッション状態の間で必ず**競合（レースコンディション）**を引き起こし、無限リダイレクトループの温床となる。

この問題を根本的に解決するため、サーバーサイドでの認証判定によるリダイレクトを完全に排除し、すべての認証ロジックをクライアントサイドで完結させる。

---

## コンポーネントの役割と責務

### 1. `AuthProvider` (`src/hooks/use-auth.tsx`) -【認証状態の唯一の管理者】

*   **責務**: アプリケーション全体の認証状態を管理する、**唯一の信頼できる情報源（Single Source of Truth）**である。
*   **仕組み**:
    *   Firebase Client SDK の **`onAuthStateChanged`** を利用して、ユーザーのログイン状態（`User`オブジェクト）をリアルタイムでリッスンする。
    *   取得した`user`オブジェクト、`loading`状態、そして管理権限 (`isAdmin`) をReact Context経由でアプリケーション全体に提供する。
    *   ユーザーがログインしたら、そのIDトークンをシングルトンの`apiClient`にセットする。これにより、以降のAPIリクエストには自動で`Authorization: Bearer <token>`ヘッダーが付与される。
    *   ログアウト処理もここに集約する。

### 2. `AuthForm` (`src/components/auth-form.tsx`) -【認証実行の専門家】

*   **責務**: ユーザーからの入力（メールアドレス/パスワード）を受け取り、Firebaseへの認証リクエスト（サインアップまたはログイン）を実行すること**だけ**に専念する。
*   **仕組み**:
    *   `createUserWithEmailAndPassword` または `signInWithEmailAndPassword` を呼び出す。
    *   **重要な点**: 認証成功後、このコンポーネントは**一切のサーバーAPIを呼び出さない**。セッションCookieの作成依頼などは行わない。
    *   認証が成功したら、Next.jsの`useRouter`を使って、固定の宛先（`/dashboard`）へリダイレクトする。**リダイレクト先を動的に決定するなどの複雑なロジックは持たない。**
    *   リダイレクト後、`AuthProvider`が新しい認証状態を検知し、アプリケーション全体の状態が更新される。

### 3. `AppLayout` (`src/app/(app)/layout.tsx`) -【認証必須ページの門番】

*   **責務**: `/dashboard`や`/memories/...`など、認証が必須なすべてのページをラップし、未認証ユーザーのアクセスを防ぐ。
*   **仕組み**:
    *   `useAuth()`フックから`user`と`loading`状態を取得する。
    *   **`useEffect`**フック内で、`loading`が`false`になった時点（認証状態が確定した時点）で`user`の存在をチェックする。
    *   もし`user`が存在しなければ、ログインページ（`/login`）へ強制的にリダイレクトする。
    *   `user`が存在すれば、子コンポーネント（実際のページ）のレンダリングを許可する。

### 4. `apiClient` (`src/lib/api-client.ts`) - 【認証情報付きAPIクライアント】

*   **責務**: APIリクエスト時に、常に最新のIDトークンを付与する。
*   **仕組み**:
    *   `AuthProvider`がログインを検知した際に`setToken()`メソッドでIDトークンを受け取る。
    *   `fetch`メソッドは、内部で保持しているトークンを`Authorization`ヘッダーに設定してからリクエストを送信する。

### 5. `middleware.ts` - 【認証に関与しない交通整理員】

*   **責務**: 認証状態の判定やリダイレクトには**一切関与しない**。
*   **現在の役割**: リクエストヘッダーに`x-pathname`を追加するなど、認証とは無関係な軽量の処理に限定されている。これにより、Edge Runtimeでの実行時エラーを完全に回避する。

---

## フローのまとめ

1.  ユーザーが保護ページ（例: `/dashboard`）にアクセス。
2.  `AppLayout`が`useAuth()`でユーザー状態をチェック。`user`がいなければ`/login`へリダイレクト。
3.  ユーザーが`AuthForm`でログイン。成功すると`/dashboard`へリダイレクト。
4.  リダイレクト後、`AuthProvider`が`onAuthStateChanged`で新しいログイン状態を検知し、`user`情報を更新。
5.  `AppLayout`は更新された`user`情報を`useAuth()`経由で受け取り、ページへのアクセスを許可する。
6.  ユーザーがAPIを叩く操作（例: メディア登録）をすると、`apiClient`が自動で認証トークンを付与してリクエストを送信する。

このアーキテクチャは、責務を明確に分離し、状態管理をクライアントに一元化することで、これまでの認証に関するすべての問題を解決した、最も堅牢で信頼性の高い構成である。
