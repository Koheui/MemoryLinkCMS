# 【重要】MemoryLinkCMS ログイン実装：失敗パターンの徹底分析と再発防止策

## 序文

このドキュメントは、MemoryLinkCMSのログイン機能実装において発生した、一連の深刻な問題とその根本原因を記録するものである。
目的は、**同じ過ちを二度と繰り返さないこと**。今後のいかなる認証フローの変更も、このドキュメントに記載された「失敗の教訓」を必ず参照し、同じ轍を踏まないことを徹底しなければならない。

---

## 失敗パターン1：`middleware.ts`の役割誤認とランタイムの衝突【最も深刻】

### 何が問題だったか？

Next.jsの`middleware.ts`ファイルに、**過剰な責務**を持たせようとしたことが全ての元凶であった。

当初、`middleware`内でセッションCookieを検証し、ユーザー情報を取得、さらにそのユーザーが所有する`memoryId`をFirestoreから取得して、動的にリダイレクト先を決定するという、極めて重厚なロジックを実装しようと試みた。

しかし、これは根本的な設計ミスであった。なぜなら、

1.  **ランタイムの非互換性**: Next.jsの`middleware`は、デフォルトで軽量な**Edge Runtime**で動作する。一方、`firebase-admin` SDKは、Node.jsのAPI（`http`アダプタやファイルシステム等）に依存しており、**Node.js Runtime**でしか正常に動作しない。この二つを同居させようとした結果、「`Dynamic Code Evaluation is not allowed`」や「`module 'path' not found`」といった、解決困難なランタイムエラーが頻発した。
2.  **複雑なリダイレクトループ**: `middleware`がリダイレクトを試みるタイミングと、クライアントサイド（`auth-form.tsx`）が`window.location.assign()`で画面遷移するタイミングが競合（レースコンディション）した。これにより、APIへのリクエストが意図せずHTMLページを返し、「`Unexpected token '<' ... is not valid JSON`」エラーを引き起こしたり、最悪の場合、無限リダイレクトループに陥った。
3.  **404エラーの誘発**: `middleware`内でFirestoreから`memoryId`を取得する処理が失敗した場合の考慮が漏れており、リダイレクト先が`undefined`となり、ユーザーはログイン直後に404ページに飛ばされるという最悪の体験を招いた。

### 教訓

-   **`middleware.ts`は交通整理員と心得るべし**: `middleware`の責務は、ヘッダーの書き換えや、非常に単純な条件（Cookieの有無など）に基づくリダイレクト/リライトに限定する。**`middleware`内で外部DBへのアクセスや、重いサーバーサイド処理を実行してはならない。**
-   **ランタイムを意識せよ**: `firebase-admin`のようなNode.js依存のライブラリは、`middleware`（Edge Runtime）では決して使用しない。認証情報の検証やデータ取得は、必ずAPI RoutesやReact Server Componentsなど、Node.js環境で実行される場所で行う。
-   **最終的な解決策**: `middleware.ts`は、「何もしない、ただリクエストを次に渡すだけ」の最小限のコードに留めることで、全ての関連エラーを根絶した。

---

## 失敗パターン2：クライアントサイドでの過剰な責務

### 何が問題だったか？

ログインコンポーネント（`src/components/auth-form.tsx`）に、認証処理**以外**のロジックを持たせようとしたことも失敗の一因であった。

ログイン成功後、そのまま`auth-form.tsx`内でFirestoreにアクセスして`memoryId`を取得し、動的にリダイレクト先を決定しようと試みた時期があった。

これは、以下の理由で失敗した。

1.  **関心の分離の原則違反**: `auth-form.tsx`の責務は「ユーザー入力の検証と認証リクエスト」であるべきで、「次のページの決定」というナビゲーションロジックを持つべきではなかった。
2.  **コードの複雑化**: 本来シンプルであるべき認証フォームが、非同期のデータ取得処理を内包し、非常に見通しが悪くなった。

### 教訓

-   **コンポーネントの責務は単一にせよ**: `auth-form.tsx`の仕事は、認証を完了させ、**ただ一つの、固定の、安全な場所（今回は `/account`）へユーザーを送り出すこと**だけである。
-   **遷移後のことは遷移先に任せる**: ユーザーをどこに案内するかの決定は、遷移先のページ（今回は`/account`にリダイレクトさせた後、`layout.tsx`）が責任を持って行う。

---

## 最終的に成功した、唯一の正しい認証フロー

上記全ての失敗を経て、最終的に以下のシンプルかつ堅牢なフローにたどり着いた。これが現在の、そして今後のMemoryLinkCMSにおける認証の**正解**である。

1.  **`auth-form.tsx` (認証担当)**
    *   Firebase Authで認証（サインアップ or ログイン）。
    *   サーバーAPI (`/api/auth/sessionLogin`) にIDトークンを送り、セッションCookieの作成を依頼する。
    *   成功後、**`window.location.assign('/account')`** を実行する。**これ以外の遷移先を指定してはならない。**

2.  **`middleware.ts` (交通整理担当)**
    *   **何もしない。** リクエストをそのまま次の処理へ渡す。
    *   Next.jsのビルド要件を満たすため、空の`middleware`関数をエクスポートするだけ。

3.  **`src/app/(app)/layout.tsx` (ページ案内担当)**
    *   `/account`ページを含む、認証後ページの共通レイアウト。
    *   このコンポーネントが表示される時点で、ユーザーは完全に認証済みである。
    *   `useEffect`と`useAuth`フックを使い、ログインユーザーの`uid`を元にFirestoreから`memoryId`を取得する。
    *   取得した`memoryId`を元に、サイドバーの「編集ページ」ボタンのリンク先を動的に **`/memories/{memoryId}`** に設定する。
    *   （改善案）ユーザーが`/account`に直接アクセスした場合、取得した`memoryId`を使って`/memories/{memoryId}`へ自動リダイレクトさせる処理を追加してもよい。

このアーキテクチャは、各コンポーネントの責務を明確に分離し、ランタイムの衝突を避け、レースコンディションを発生させない、最も安定した構成である。
