# 【重要】MemoryLinkCMS ログイン実装：失敗パターンの徹底分析と最終的な解決策

## 序文

このドキュメントは、MemoryLinkCMSのログイン機能実装において発生した、一連の深刻な問題とその根本原因を記録するものである。
目的は、**同じ過ちを二度と繰り返さないこと**。今後のいかなる認証フローの変更も、このドキュメントに記載された「失敗の教訓」を必ず参照し、同じ轍を踏まないことを徹底しなければならない。

---

## 失敗パターン1：`middleware.ts`の役割誤認とランタイムの衝突【最も深刻】

### 何が問題だったか？

Next.jsの`middleware.ts`ファイルに、**過剰な責務**を持たせようとしたことが全ての元凶であった。

当初、`middleware`内でセッションCookieを検証し、ユーザー情報を取得、さらにそのユーザーが所有する`memoryId`をFirestoreから取得して、動的にリダイレクト先を決定するという、極めて重厚なロジックを実装しようと試みた。

しかし、これは根本的な設計ミスであった。なぜなら、

1.  **ランタイムの非互換性**: Next.jsの`middleware`は、デフォルトで軽量な**Edge Runtime**で動作する。一方、`firebase-admin` SDKは、Node.jsのAPI（`http`アダプタやファイルシステム等）に依存しており、**Node.js Runtime**でしか正常に動作しない。この二つを同居させようとした結果、「`Dynamic Code Evaluation is not allowed`」や「`module 'path' not found`」といった、解決困難なランタイムエラーが頻発した。
2.  **認証状態の競合**: クライアントサイドのFirebase Auth SDK（`onAuthStateChanged`）による認証状態と、サーバーサイドの`middleware`によるセッションCookie検証の結果が、ページの読み込みタイミングによって競合（レースコンディション）した。これにより、ログイン直後にも関わらず「未認証」と判断されてログインページにリダイレクトされる、無限ループに陥った。
3.  **Firestoreアクセスの失敗**: `middleware`内でFirestoreから`memoryId`を取得する処理が失敗した場合の考慮が漏れており、リダイレクト先が`undefined`となり、ユーザーはログイン直後に404ページに飛ばされるという最悪の体験を招いた。

### 教訓

-   **`middleware.ts`は交通整理員と心得るべし**: `middleware`の責務は、リクエストヘッダーの書き換えや、ごく単純な条件（特定のパスへのアクセス制御など）に基づくリダイレクト/リライトに限定する。**`middleware`内で外部DBへのアクセスや、重いサーバーサイド処理を実行してはならない。**
-   **認証の源泉は一つに絞れ**: クライアントサイドの認証状態とサーバーサイドのセッションを両方使おうとすると、必ず競合する。Next.js App Routerでは、**Firebase Client SDK (`onAuthStateChanged`) を唯一の認証情報源（Single Source of Truth）**として扱うのが最もシンプルで堅牢である。
-   **最終的な解決策**: `middleware.ts`は、リクエストヘッダーを追加するだけの最小限のコードに留め、認証判定のロジックを全て削除することで、関連エラーを根絶した。

---

## 失敗パターン2：クライアントサイドでの過剰なリダイレクト責務

### 何が問題だったか？

ログインコンポーネント（`src/components/auth-form.tsx`）が、認証処理**後**のリダイレクト先を賢く判断しようとしたことも失敗の一因であった。

ログイン成功後、`auth-form.tsx`内でFirestoreにアクセスして`memoryId`を取得し、動的にリダイレクト先を決定しようと試みたが、これは以下の問題を引き起こした。

1.  **関心の分離の原則違反**: `auth-form.tsx`の責務は「ユーザー入力の検証と認証リクエストの実行」であるべきで、「次のページの決定」というナビゲーションロジックを持つべきではなかった。
2.  **コードの複雑化**: 本来シンプルであるべき認証フォームが、非同期のデータ取得処理を内包し、見通しが悪くなった。
3.  **遷移タイミングの不定性**: データ取得の成否や速度によって、ユーザーが次にどのページを見るかが不安定になった。

### 教訓

-   **コンポーネントの責務は単一にせよ**: `auth-form.tsx`の仕事は、認証を完了させ、**ただ一つの、固定の、安全な場所（今回は `/account`）へユーザーを送り出すこと**だけである。
-   **遷移後のことは遷移先に任せる**: ユーザーを最終的にどこに案内するかの決定は、遷移先の共通レイアウト (`src/app/(app)/layout.tsx`) が責任を持って行うべきである。

---

## 最終的に成功した、唯一の正しい認証フロー

上記全ての失敗を経て、最終的に以下のシンプルかつ堅牢なフローにたどり着いた。これが現在の、そして今後のMemoryLinkCMSにおける認証の**正解**である。

1.  **`Auth Provider` (`src/hooks/use-auth.tsx`)**
    *   アプリケーションの認証状態を管理する唯一の中心。
    *   Firebase Client SDK の **`onAuthStateChanged`** を使用して、ユーザーのログイン状態をリアルタイムで監視する。これが**唯一の信頼できる情報源**である。
    *   ユーザーのログイン/ログアウトを検知し、`user`オブジェクトと`loading`状態をコンテキストとして配下のコンポーネントに提供する。

2.  **ログインフォーム (`src/components/auth-form.tsx`)**
    *   Firebase Authで認証（サインアップ or ログイン）。
    *   **サーバーサイドのAPIは一切呼び出さない。**
    *   認証成功後、**`window.location.assign('/account')`** を実行する。行き先は固定の単一の場所とし、複雑な判定は行わない。

3.  **共通レイアウト (`src/app/(app)/layout.tsx`)**
    *   `/account` や `/memories/...` など、認証が必要な全てのページをラップする。
    *   `useAuth()` フックから `user` と `loading` を受け取る。
    *   **`useEffect`** を使い、`loading`が`false`になった時点で`user`の存在をチェックする。
    *   `user`がいなければ、`/login`にリダイレクトする。
    *   `user`がいれば、そのユーザーの`uid`を元にFirestoreから`memoryId`を取得し、編集ページへのリダイレクトやサイドバーのリンク設定を行う。

このアーキテクチャは、**認証状態の判断をクライアントサイドの`onAuthStateChanged`に一任**し、各コンポーネントの責務を明確に分離することで、ランタイムの衝突やレースコンディションを完全に排除した、最も安定的で標準的な構成である。